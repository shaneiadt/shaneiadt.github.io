{"pages":[],"posts":[{"title":"Are Class Components Dead? - React Hooks","text":"Since the full release of Hooks with React version 16.8 the community has almost gone insane. Some developers have gone so bat shit crazy they’ve re-written all their apps to use React Hooks! What are hooks? Plainly put, like most things JavaScript they’re just functions….simples! But with the power of scope closures they expose the beauty of Reacts state, lifecycle methods &amp; even Context API. You can even write your own hooks if you fancy. What kind of stuff can we do with Hooks, why should I care? Class components work just fine when I need some state &amp; functional components are great for returning some JSX using a straight forward JS function. But wouldn’t it be cool if you could upgrade these functional components to have their own internal state or do some processing when mounted instead of relying on the parent component to decide if it needs to be re-render or not. Let’s start off simple &amp; sprinkle a bit of state on the situation. useStateThis hook is amazing, it works slightly different from the class based approach. Instead of managing your state in one big object, which you still can do of course. With useState we can create slices of state like so. View Demo Code 12345678910111213141516171819202122232425262728293031import React, &#123; useState &#125; from \"react\";import ReactDOM from \"react-dom\";function WhatTheState() &#123; const [count, setCount] = useState(0); const [text, setText] = useState(null); return ( &lt;div style=&#123;&#123; textAlign: \"center\" &#125;&#125;&gt; &#123;text !== null ? ( &lt;div&gt; &lt;p&gt; Hello my name is &#123;text&#125; &amp; you pushed my button &#123;count&#125; times &lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;Click me&lt;/button&gt; &lt;/div&gt; ) : null&#125; &#123;text === null ? &lt;p&gt;Enter your name to start pushing!!&lt;/p&gt; : null&#125; &lt;p&gt; &lt;input type=\"text\" value=&#123;text&#125; onChange=&#123;event =&gt; setText(event.target.value)&#125; /&gt; &lt;/p&gt; &lt;/div&gt; );&#125;const rootElement = document.getElementById(\"root\");ReactDOM.render(&lt;WhatTheState /&gt;, rootElement); Bam your functional components can now manage their own state in slices….super sweet I know. The only downside to using this approach is when you are updating your state slice you will need to supply all values otherwise they won’t be included. What’s next you ask? What about when our component mounts, checks for updates or is destroyed? Lets control what happens when our component mounts to the DOM using the handy useEffect hook. useEffectWe can manipulate or hook into the render cycles of our component now like so. View Code Demo 123456789101112131415161718192021222324252627282930313233343536import React, &#123; useState, useEffect &#125; from \"react\";import ReactDOM from \"react-dom\";function WhatTheState() &#123; const [count, setCount] = useState(0); const [text, setText] = useState(null); useEffect(() =&gt; &#123; // Just Like componentDidMount() setText(\"Johnny\") &#125;,[]) return ( &lt;div style=&#123;&#123; textAlign: \"center\" &#125;&#125;&gt; &#123;text !== null ? ( &lt;div&gt; &lt;p&gt; Hello my name is &#123;text&#125; &amp; you pushed my button &#123;count&#125; times &lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;Click me&lt;/button&gt; &lt;/div&gt; ) : null&#125; &#123;text === null ? &lt;p&gt;Enter your name to start pushing!!&lt;/p&gt; : null&#125; &lt;p&gt; &lt;input type=\"text\" value=&#123;text&#125; onChange=&#123;event =&gt; setText(event.target.value)&#125; /&gt; &lt;/p&gt; &lt;/div&gt; );&#125;const rootElement = document.getElementById(\"root\");ReactDOM.render(&lt;WhatTheState /&gt;, rootElement); No need to create a stateful container anymore! Cool right? Well that’s not all we can do. We can also trigger the render based on some state change by telling the hook what to watch. Add variables to the array you’d like your component to watch &amp; your useEffect() function will trigger again. 1234useEffect(() =&gt; &#123; // Similar to componentDidUpdate, we are watching for changes to the text variable setText(\"Johnny\") &#125;,[text]) Last but not least we can also fire some function based on the component unmounting too. By default if your useEffect function returns a function it will invoke it when the component is unmounted. 1234567useEffect(() =&gt; &#123; // Similar to componentDidUpdate, we are watching for changes to the text variable setText(\"Johnny\") return function cleanup() &#123; // Do some cleanup logic here! &#125;; &#125;,[text]) What if we’re using some global state i hear you ask? Enter React’s Context API….but wait because we’re using functional components we need to use a hook instead…useContext hook to be exact. useContextBy far for me this hook is one of the best. I wouldn’t say I’ve had any issues with React but for a long time there was no way to manage global app state without using a third party package such as React Redux or React Easy State. Passing props around to other components can be ok when it’s two or three, but when you’re passing down props through maybe 5 different components just to tell a button the app is in a loading state it becomes a bit much! View Demo Code 12345678910111213141516171819202122232425262728293031323334353637import React from \"react\";import ReactDOM from \"react-dom\";import \"./styles.css\";class App extends React.Component &#123; state = &#123; loading: true &#125;; render() &#123; return ( &lt;div className=\"App\"&gt; &lt;Form loading=&#123;this.state.loading&#125; /&gt; &lt;/div&gt; ); &#125;&#125;const Form = (&#123; loading &#125;) =&gt; &#123; return ( &lt;form&gt; &lt;h2&gt;Fill Me In&lt;/h2&gt; &lt;input type=\"text\" /&gt; &lt;p&gt; &lt;Button loading=&#123;loading&#125; /&gt; &lt;/p&gt; &lt;/form&gt; );&#125;;const Button = (&#123; loading &#125;) =&gt; &#123; if (loading) return &lt;p&gt;No Button Form is Loading&lt;/p&gt;; return &lt;button type=\"submit\"&gt;Submit&lt;/button&gt;;&#125;;const rootElement = document.getElementById(\"root\");ReactDOM.render(&lt;App /&gt;, rootElement); Do not fret my friends, useContext gives us access to extend our functional components. The below example illustrates how we can create some context &amp; subscribe to it within our functional components using Reacts useContext hook. View Code Demo 123456789101112131415161718192021222324252627282930313233343536373839404142import React from \"react\";import ReactDOM from \"react-dom\";import \"./styles.css\";const AppContext = React.createContext(&#123; loading: \"\" &#125;);class App extends React.Component &#123; state = &#123; loading: true &#125;; render() &#123; return ( &lt;AppContext.Provider value=&#123;&#123; ...this.state &#125;&#125;&gt; &lt;div className=\"App\"&gt; &lt;Form loading=&#123;this.state.loading&#125; /&gt; &lt;/div&gt; &lt;/AppContext.Provider&gt; ); &#125;&#125;const Form = () =&gt; &#123; return ( &lt;form&gt; &lt;h2&gt;Fill Me In&lt;/h2&gt; &lt;input type=\"text\" /&gt; &lt;p&gt; &lt;Button /&gt; &lt;/p&gt; &lt;/form&gt; );&#125;;const Button = (&#123; loading &#125;) =&gt; &#123; const context = React.useContext(AppContext); if (context.loading) return &lt;p&gt;No Button Form is Loading&lt;/p&gt;; return &lt;button type=\"submit\"&gt;Submit&lt;/button&gt;;&#125;;const rootElement = document.getElementById(\"root\");ReactDOM.render(&lt;App /&gt;, rootElement); Of course you could use another state management package but I like this approach as we’re relying on one package without any third party setup, no messing around with mapStateToProps for me anymore. Why mess with extra libraries when React provides a tool for exactly what we’re trying to solve. Side note: The size of your state will most likely determine the kind of management system you want to adopt. Last but not least React gives us the option to extend this architecture with the useHook function. This is prime time for a custom hook you might have in mind. I would provide another demo but my face is tired, have a read of this if you’re interested. ConclusionFirst off, React as a whole is amazing &amp; I’m so glad I have the opportunity to develop with it every day…and get paid! Hooks are an amazing feature the React team have provided us with but understanding the core concepts of the React ecosystem &amp; architecture in my opinion boils down to a strong grasp of stateful vs functional components. If you can write an app using only class based stateful components go right ahead, stateful container components aren’t leaving us anytime soon. Class components are a staple in React as far as understanding goes that’s for sure. Hooks just give it a little extension for those pure functions that don’t require a full state render method to be defined. Need some scoped state, useState…need some lifecycle management / side-effects to happen useEffect…want to clean up your global context state useContext…have an idea for a reusable hook…build your own! There are a couple of advanced uses regarding useContext coupled with useReducer &amp; some Higher Order Components (HOC) to completely over all your state management which you can have a read of here. Also I’d like to point out there are a couple more hooks I haven’t mention in this article for example useMemo, useRef &amp; a couple others. Love hooks or React? Read more React Hooks","link":"/2019/06/22/Are-Class-Components-Dead-React-Hooks/"},{"title":"(CSS) Magic Is Real With Houdini","text":"Fed up with bloated hacky JavaScript manipulating CSS? Me too! Enter the Houdini Task Force with one simple goal…outline a collection of drafts to be accepted by W3C &amp; added as common web standards. Well it doesn’t seem that simple but these guys are making great strides for the web and developers sake. Houdini will in essence offer the ability to extend the CSS rendering engine with low-level JavaScript APIs. Which will allow authors to extend the CSS engine offering massive improvements &amp; capabilities from a user experience &amp; performance point of view. Specifications Worklets CSS Paint API CSS Animation Worklet CSS Layout API Typed CSSOM WorkletsView specification Worklets themselves aren’t really anything to write home about. Similar to a Web Worker a Worklet is more of a concept that makes use of ES2015 class definitions helping to expose these low-level APIs within our browser. So what is a Worklet? A Worklet is almost like a mini event loop (what is the event loop) that can attach or reposition itself to different events it is configured to. In the words of Surma think of it as your swiss army knife to accessing these low-level APIs. Let’s look at our first low-level API that Worklets give us access to, the CSS Paint API. As most of these specs are still in the draft phase you may need to enable experimental web features to see them in action. chrome://flags/#enable-experimental-web-platform-featuresRead more about Worklets CSS Paint APIView specification Ok what the hell does this thing do you ask &amp; why should I be excited about it! Imagine being able to programmatically control exactly what, when &amp; how an object is drawn to the screen. With greater control using SVGs or jamming image files into your CSS may well become less of a headache. Instead of using things like background-image or border-image you can now reference a paint worklet like so paint(myPainter). Enough with the jabber show me the goodies dag-nab-it! Example Read more about CSS Paint API CSS Animation WorkletView specification This super-sweet Worklet allows us to run a set of instructions on a device at it’s native frame rate preventing jumpy &amp; awkward animations. The first port of call for most animations in CSS is CSS Transitions, CSS Animations &amp; the more complex Web Animations API. With the CSS Animation API / Worklet we can listen for any user input even scroll events! This topic is quite extensive so to prevent boredom I suggest checking out the example below &amp; read more if you fancy. Example Read more about CSS Animation Worklet CSS Layout APIView specification With the ability to create &amp; control your layouts with enormous detail never imagined before! The layout worklet can even help you build your own layouts &amp; pass them into the display property, like so display: layout(&#39;myLayout&#39;). Example Read more about the CSS Layout API Typed CSSOMView specification CSS Object Model or Cascading Style Sheets Object Model (Typed CSSOM). If you are familiar with a programming language or two you might have stumbled upon some Object Oriented stuff &amp; data types. What this specification focuses on is the typing part, mainly the typing of CSS values as JavaScript objects. With Typed CSSOM every CSS value is now a member of a new base class called CSSStyleValue. These values can then be extended to help authors manage calculations &amp; different value types such as rem, px, em &amp; percent. Example The Task ForceWith engineers from the likes of Apple, Google &amp; Microsoft working together (i know scary right!) on these potentially new web standards how could you not be excited! ConclusionI wanted to keep these sections brief…so there you have it! Not all the specifications are fully stable at the moment but Houdini &amp; Worklets won’t be going away anytime soon. Keep your ear close to the coconut on this one peoples. Resources Is Houdini Ready Yet? CSS Houdini Github Wiki Houdini updates on developer.google. Houdini draft specifications Chrome Dev Summit Video Google Chrome Lab Houdini Examples","link":"/2019/03/29/CSS-Magic-is-real-with-Houdini/"}],"tags":[{"name":"React Hooks","slug":"React-Hooks","link":"/tags/React-Hooks/"},{"name":"Javascript","slug":"Javascript","link":"/tags/Javascript/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"Houdini","slug":"Houdini","link":"/tags/Houdini/"},{"name":"JavaScript API","slug":"JavaScript-API","link":"/tags/JavaScript-API/"}],"categories":[]}